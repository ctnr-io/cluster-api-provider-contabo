
#cloud-config
package_update: true

write_files:
  - path: /usr/local/bin/contabo-network-cleanup.sh
    owner: 'root:root'
    permissions: '0755'
    content: |
      #!/bin/sh
  
      ip route | grep -v eth0 | grep -v default | grep -v ${PRIVATE_NETWORK_CIDR}
      xargs -I {} sh -c 'sudo ip route del {}'
  - path: /usr/local/bin/contabo-network-cleanup.service
    owner: 'root:root'
    permissions: '0644'
    content: |
      [Unit]
      Description=Cleanup bad network routes
      After=network.target
  
      [Service]
      Type=oneshot
      ExecStart=/usr/local/bin/contabo-network-cleanup.sh
  
      [Install]
      WantedBy=multi-user.target
  - path: /etc/modules-load.d/k8s.conf
    owner: 'root:root'
    permissions: '0644'
    content: |
      overlay
      br_netfilter
  - path: /etc/sysctl.d/k8s.conf
    owner: 'root:root'
    permissions: '0644'
    content: |
      net.bridge.bridge-nf-call-iptables  = 1
      net.bridge.bridge-nf-call-ip6tables = 1
      net.ipv4.ip_forward                 = 1
      net.ipv6.conf.all.forwarding = 1
  - path: /etc/cron.d/etcd-backup
    owner: 'root:root'
    permissions: '0644'
    content: |
      # Run etcd backup daily at midnight
      0 0 * * * root /usr/local/bin/etcd-backup.sh > /var/log/etcd-backup.log 2>&1
  - path: /usr/local/bin/etcd-backup.sh
    owner: 'root:root'
    permissions: '0755'
    content: |
      #!/bin/bash
  
      set -e
  
  
      BACKUP_DIR="/var/lib/etcd/backup"
  
      BACKUP_DATE=$(date +%Y%m%d-%H%M%S)
  
      BACKUP_FILE="$BACKUP_DIR/etcd-snapshot-$BACKUP_DATE.db"
  
  
      # Create backup directory if it doesn't exist
  
      mkdir -p $BACKUP_DIR
  
  
      # Backup etcd using kubectl exec (since etcd runs as a pod)
  
      echo "Creating etcd snapshot: $BACKUP_FILE"
  
      sudo ETCDCTL_API=3 kubectl -n kube-system exec -it etcd-$(hostname) --
      etcdctl \
        --endpoints=https://127.0.0.1:2379 \
        --cacert=/etc/kubernetes/pki/etcd/ca.crt \
        --cert=/etc/kubernetes/pki/etcd/server.crt \
        --key=/etc/kubernetes/pki/etcd/server.key \
        snapshot save $BACKUP_FILE
  
      # Keep only the last 5 backups
  
      echo "Cleaning up old backups..."
  
      ls -t $BACKUP_DIR/etcd-snapshot-*.db | tail -n +6 | xargs -r rm
  
  
      echo "Etcd backup completed successfully"
  - path: /usr/local/bin/etcd-restore.sh
    owner: 'root:root'
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e
  
      # Check if backup file is provided
      if [ -z "$1" ]; then
        echo "Usage: $0 <backup-file>"
        exit 1
      fi
  
      BACKUP_FILE="$1"
  
      # Check if backup file exists
      if [ ! -f "$BACKUP_FILE" ]; then
        echo "ERROR: Backup file $BACKUP_FILE does not exist"
        exit 1
      fi
  
      echo "Restoring etcd from backup: $BACKUP_FILE"
  
      # Stop kubelet to prevent it from restarting etcd
      sudo systemctl stop kubelet
  
      # Remove existing etcd data directory
      sudo rm -rf /var/lib/etcd
  
      # Restore from snapshot
      sudo ETCDCTL_API=3 etcdctl snapshot restore "$BACKUP_FILE" \
        --data-dir=/var/lib/etcd \
        --name=$(hostname) \
        --initial-cluster=$(hostname)=https://localhost:2380 \
        --initial-advertise-peer-urls=https://localhost:2380
  
      echo "Etcd restore completed successfully"

packages:
  - etcd-client
  - apt-transport-https
  - curl
  - gpg
  - sudo
  - ca-certificates
  - gnupg
  - kubectl
  - cron

runcmd:
  - |
    #!/bin/sh
    # Remove unused network subnet configuration from contabo at boot time
    sudo mkdir -p /usr/local/bin
    sudo systemctl daemon-reload
    sudo systemctl enable contabo-network-cleanup.service
    sudo systemctl start contabo-network-cleanup.service
  
  - |
    # Add Docker's official GPG key
    sudo install -m 0755 -d /etc/apt/keyrings
    sudo rm -rf /etc/apt/keyrings/docker.gpg
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor --batch --no-tty -o /etc/apt/keyrings/docker.gpg
    sudo chmod a+r /etc/apt/keyrings/docker.gpg
  
  - |
    # Add the repository to Apt sources
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
    curl -fsSL https://gvisor.dev/archive.key | sudo apt-key add -  
    sudo add-apt-repository "deb [arch=amd64] https://storage.googleapis.com/gvisor/releases release main"  
  
  - |
    # Update apt and install containerd & runsc
    export DEBIAN_FRONTEND=noninteractive
    sudo apt-get update
    sudo apt-get install -y containerd.io runsc
  
  - |
    # Configure containerd for Kubernetes
    sudo mkdir -p /etc/containerd
    containerd config default | sudo tee /etc/containerd/config.toml > /dev/null
  
  - |
    # Set SystemdCgroup to true for containerd
    sudo sed -i 's/SystemdCgroup = false/SystemdCgroup = true/g' /etc/containerd/config.toml
  
  - |
    # Add runsc to containerd
    cat <<EOF | sudo tee -a /etc/containerd/config.toml
    [plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runsc]
      runtime_type = "io.containerd.runsc.v1"
    EOF
  
  - |
    # Enable containerd service
    sudo systemctl enable containerd
  
  - |
    # Restart containerd
    sudo systemctl restart containerd
  
  - |
    # Update sysctl settings
    sudo sysctl --system
  
  - |
    export DEBIAN_FRONTEND=noninteractive
    # 1. Update the apt package index and install packages needed to use the Kubernetes apt repository:
    sudo apt-get update
    # apt-transport-https may be a dummy package; if so, you can skip that package
    sudo apt-get install -y apt-transport-https ca-certificates curl gpg
  
  - |
    # 2. Download the public signing key for the Kubernetes package repositories. The same signing key is used for all repositories so you can disregard the version in the URL:
    # If the directory '/etc/apt/keyrings' does not exist, it should be created before the curl command, read the note below.
    sudo mkdir -p -m 755 /etc/apt/keyrings
    sudo rm -rf /etc/apt/keyrings/kubernetes-apt-keyring.gpg
    curl -fsSL https://pkgs.k8s.io/core:/stable:/${KUBEADM_VERSION}/deb/Release.key | sudo gpg --dearmor --batch --no-tty -o /etc/apt/keyrings/kubernetes-apt-keyring.gpg
  
  - |
    # 3. Add the appropriate Kubernetes apt repository.
    # Please note that this repository have packages only for Kubernetes ${KUBEADM_VERSION};
    # for other Kubernetes minor versions,
    # you need to change the Kubernetes minor version in the URL to match your desired minor version
    # (you should also check that you are reading the documentation for the version of Kubernetes that you plan to install).
    # This overwrites any existing configuration in /etc/apt/sources.list.d/kubernetes.list
    echo 'deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/${KUBEADM_VERSION}/deb/ /' | sudo tee /etc/apt/sources.list.d/kubernetes.list
  
  - |
    export DEBIAN_FRONTEND=noninteractive
    # 4. Update the apt package index, install kubelet, kubeadm and kubectl, and pin their version:
    sudo apt-get update
    sudo apt-get install -y kubelet kubeadm kubectl
    sudo apt-mark hold kubelet kubeadm kubectl
  
  - |
    # 5. (Optional) Enable the kubelet service before running kubeadm:
    sudo systemctl enable --now kubelet
  
  - |
    export DEBIAN_FRONTEND=noninteractive
    curl https://baltocdn.com/helm/signing.asc | gpg --dearmor --batch --no-tty | sudo tee /usr/share/keyrings/helm.gpg > /dev/null
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/helm.gpg] https://baltocdn.com/helm/stable/debian/ all main" | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list
    sudo apt-get update
    sudo apt-get install helm
  
